<!doctype HTML>

<html>
    <head>
        <meta charset="utf-8">
        <title>WebGPU Life</title>
    </head>
    <body>
        <canvas width="512" height="512"></canvas>
        <script type="module">

            const UPDATE_INTERVAL = 200;

            const WORKGROUP_SIZE = 8;

            const canvas = document.querySelector("canvas");
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            const adapter = await navigator.gpu.requestAdapter();
            if(!adapter) {
                throw new Error("No appropritae GPUAdapter found.");
            }
            const device = await adapter.requestDevice();
            const context = canvas.getContext("webgpu");
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device: device,
                format: canvasFormat,
            });

            const uniformBuffer = device.createBuffer({
                label: "Shape Uniforms",
                size: 64,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });

            updateUniforms([0, 0], [0, 0], [0,0], 0)

            const vertices = new Float32Array([
            //   X,    Y,
                -0.8, -0.8,
                0.8, -0.8,
                -0.8,  0.8,

                0.8, -0.8,
                0.8,  0.8,
                -0.8,  0.8,
            ]);

            const vertexBuffer = device.createBuffer({
                label: "Shape vertices",
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            })

            device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/0, vertices);

            const vertexBufferLayout = {
                arrayStride: 8,
                attributes: [{
                    format: "float32x2",
                    offset: 0,
                    shaderLocation: 0,
                }],
            };

            const shapeShaderModule = device.createShaderModule({
                label: "Shape shader",
                code: `
                    // shader code
                    struct VertexInput {
                        @location(0) pos: vec2f,
                    };

                    struct VertexOutput {
                        @builtin(position) pos: vec4f,
                    };

                    struct Uniforms {
                        pos : vec2f,
                        vel : vec2f,
                        acc : vec2f,
                        rot : f32,
                    };
                    
                    @group(0) @binding(0) var<uniform> uniforms: Uniforms;

                    @vertex
                    fn vertexMain(input: VertexInput) -> VertexOutput {
                        var output : VertexOutput;
                        output.pos = vec4f(input.pos + uniforms.pos, 0, 1);
                        //output.pos = vec4f(input.pos, 0, 1);
                        return output;
                    }
                    
                    @fragment
                    fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
                        return vec4f(1, 1, 0, 1);
                    }
                `
            })

            const simulationShaderModule = device.createShaderModule({
                label: "Game of Life simulation shader",
                code: `
                    struct Uniforms {
                        pos : vec2f,
                        vel : vec2f,
                        acc : vec2f,
                        rot : f32,
                    };

                    @group(0) @binding(0) var<uniform> uniforms: Uniforms;
                    
                    @compute
                    @workgroup_size(1)
                    fn computeMain(@builtin(global_invocation_id) cell: vec3u) {
                        
                    }
                    `
            });

            // create the bind group layout and pipeline layout
            const bindGroupLayout = device.createBindGroupLayout({
                label: "bind Group Layout",
                entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,
                    buffer: {}
                }
                ]
            });

            const bindGroups = [
                device.createBindGroup({
                    label: "bind group",
                    layout: bindGroupLayout,
                    entries: [
                    {
                        binding: 0,
                        resource: { buffer: uniformBuffer }
                    }
                    ],
                }),
            ];

            const pipelineLayout = device.createPipelineLayout({
                label: "Pipeline Layout",
                bindGroupLayouts: [ bindGroupLayout ],
            });

            const shapePipeline = device.createRenderPipeline({
                label: "Shape pipeline",
                layout: pipelineLayout,
                vertex: {
                    module: shapeShaderModule,
                    entryPoint: "vertexMain",
                    buffers: [vertexBufferLayout]
                },
                fragment: {
                    module: shapeShaderModule,
                    entryPoint: "fragmentMain",
                    targets: [{
                        format: canvasFormat
                    }]
                }
            });

            const simulationPipeline = device.createComputePipeline({
                label: "Simulation pipeline",
                layout: pipelineLayout,
                compute: {
                    module: simulationShaderModule,
                    entryPoint: "computeMain",
                }
            });

            function updateUniforms(position, velocity, acceleration, rotation) {
                const uniformArray = new Float32Array([
                    position[0], position[1],    0, 0, 
                    velocity[0], velocity[1],   0, 0, 
                    acceleration[0], acceleration[1],   0, 0,
                    rotation, 0, 0, 0
                ]);

                device.queue.writeBuffer(uniformBuffer, 0, uniformArray);
            }

            function updateShapes() {
                const encoder = device.createCommandEncoder();
                
                updateUniforms()

                //begin render pass
                const pass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        loadOp: "clear",
                        clearValue: [0, 0, 0, 1],
                        storeOp: "store",
                    }]
                });

                pass.setPipeline(shapePipeline);
                pass.setVertexBuffer(0, vertexBuffer);

                pass.setBindGroup(0, bindGroups[0]);

                pass.draw(vertices.length / 2);

                pass.end();
                const commandBuffer = encoder.finish();
                device.queue.submit([commandBuffer]);
            }

            setInterval(updateShapes, UPDATE_INTERVAL);
            
        </script>
    </body>
</html>