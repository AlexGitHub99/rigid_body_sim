<!doctype HTML>

<html>
    <head>
        <meta charset="utf-8">
        <title>WebGPU rigidbodies</title>
    </head>
    <body>
        <canvas width="512" height="512"></canvas>
        <script type="module">
            const MAX_SHAPES = 100;
            const TILE_SIZE = 2;
            const SHAPE_COLLISIONS = MAX_SHAPES*(MAX_SHAPES - 1)/2;
            const COLLISIONS = SHAPE_COLLISIONS + MAX_SHAPES*4;

            const SHAPE_MEMBERS = 9;
            const SHAPE_SIZE = 0.05;

            const CANVAS_SIZE = 1.0;
            
            const UPDATE_INTERVAL = 1000/60;
           
            const DO_FRAME_SYNCH = true;

            let step = 0;
            let frameElapsedTime = 0;


            const canvas = document.querySelector("canvas");
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            const adapter = await navigator.gpu.requestAdapter();
            if(!adapter) {
                throw new Error("No appropritae GPUAdapter found.");
            }
            const device = await adapter.requestDevice();
            const context = canvas.getContext("webgpu");
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device: device,
                format: canvasFormat,
            });
            
            const uniformBuffer = device.createBuffer({
                label: "Uniforms",
                size: 32,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            updateUniforms(SHAPE_MEMBERS, SHAPE_SIZE, UPDATE_INTERVAL, MAX_SHAPES);

            //format is flattened array of [[posx, posy], [velx, vely], rot]
            const shapeStateArray = new Float32Array(MAX_SHAPES * SHAPE_MEMBERS);
            const shapeStateStorage = 
            [
                device.createBuffer({
                    label: "Shape State A",
                    size: shapeStateArray.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }),
                device.createBuffer({
                    label: "Shape State B",
                    size: shapeStateArray.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                })
            ];

            const colTimes = device.createBuffer({
                label: "Collision times",
                size: COLLISIONS*4,
                usage: GPUBufferUsage.STORAGE,
            });

            const nextTimeIndexStorage = device.createBuffer({
                label: "Next time index value",
                size: 4,
                usage: GPUBufferUsage.STORAGE,
            });

            const remainingTimeStorage = device.createBuffer({
                label: "Remaining time value",
                size: 4,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            })

            for (let i = 0; i < MAX_SHAPES; ++i) {
                shapeStateArray[i*SHAPE_MEMBERS + 0] = -0.8 + i*(SHAPE_SIZE*0.3); //posx
                shapeStateArray[i*SHAPE_MEMBERS + 1] = 0; //posy
                shapeStateArray[i*SHAPE_MEMBERS + 2] = -Math.pow(i, 2)*0.00001; //velx
                shapeStateArray[i*SHAPE_MEMBERS + 3] = -Math.pow(i, 2)*0.00004; //vely
                shapeStateArray[i*SHAPE_MEMBERS + 4] = 0; //rotational vel
                shapeStateArray[i*SHAPE_MEMBERS + 5] = 0; //rot
                shapeStateArray[i*SHAPE_MEMBERS + 6] = 0.9; //r
                shapeStateArray[i*SHAPE_MEMBERS + 7] = 0.9; //g
                shapeStateArray[i*SHAPE_MEMBERS + 8] = 0.9; //b
            }
            device.queue.writeBuffer(shapeStateStorage[0], 0, shapeStateArray);


            const vertices = new Float32Array([
            //   X,    Y,
                -1.0, -1.0,
                1.0, -1.0,
                -1.0,  1.0,

                1.0, -1.0,
                1.0,  1.0,
                -1.0,  1.0,
            ]);

            const vertexBuffer = device.createBuffer({
                labe: "Shape vertices",
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            })

            device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/0, vertices);

            const vertexBufferLayout = {
                arrayStride: 8,
                attributes: [{
                    format: "float32x2",
                    offset: 0,
                    shaderLocation: 0,
                }],
            };

            const cellShaderModule = device.createShaderModule({
                label: "Shape shader",
                code: `
                    // shader code
                    struct VertexInput {
                        @location(0) pos: vec2f,
                        @builtin(instance_index) instance: u32,
                    };

                    struct VertexOutput {
                        @builtin(position) pos: vec4f,
                        @location(0) @interpolate(flat) instance: u32,
                    };

                    struct Uniforms {
                        shapeMembers: f32,
                        shapeSize: f32,
                        updateInterval: f32,
                    };

                    fn rotate(pos: vec2f, angle: f32) -> vec2f {
                        let rotMat = mat2x2f( vec2f(cos(angle), sin(angle)),
                                            vec2f(-sin(angle), cos(angle)));
                        let result = rotMat * pos;
                        return result;
                    }

                    @group(0) @binding(0) var<uniform> uniforms: Uniforms;
                    @group(0) @binding(1) var<storage> shapeState: array<f32>;

                    @vertex
                    fn vertexMain(input: VertexInput) -> VertexOutput {
                        let i = u32(input.instance);
                        let shapeMembers = u32(uniforms.shapeMembers);
                        let shapeIndex = i*shapeMembers;

                        let shapePos = vec2f(shapeState[shapeIndex + 0], shapeState[shapeIndex + 1]);
                        let shapeAngle = shapeState[shapeIndex + 5];

                        let scaledPos = input.pos*uniforms.shapeSize;
                        let newPos = rotate(scaledPos, shapeAngle) + shapePos;

                        var output: VertexOutput;
                        output.pos = vec4f(newPos, 0, 1);
                        output.instance = input.instance;
                        return output;
                    }
                    
                    @fragment
                    fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
                        let i = u32(input.instance);
                        let shapeMembers = u32(uniforms.shapeMembers);
                        let shapeIndex = i*shapeMembers;

                        return vec4f(shapeState[shapeIndex + 6], shapeState[shapeIndex + 7], shapeState[shapeIndex + 8], 1);
                    }
                `
            })

            const simulationShaderModule = device.createShaderModule({
                label: "Game of Life simulation shader",
                code: `
                    @group(0) @binding(0) var<uniform> uniforms: Uniforms;
                    @group(0) @binding(1) var<storage> shapeStateA: array<f32>;
                    @group(0) @binding(2) var<storage, read_write> shapeStateB: array<f32>;
                    @group(0) @binding(3) var<storage, read_write> collisionTimes: array<f32, ${COLLISIONS}>;
                    @group(0) @binding(4) var<storage, read_write> nextTimeIndex: u32;
                    @group(0) @binding(5) var<storage, read_write> remainingTime: f32;


                    const T: u32 = ${TILE_SIZE};
                    const A: u32 = 0;
                    const B: u32 = 1;
                    const TOP: i32 = -1;
                    const RIGHT: i32 = -2;
                    const BOTTOM: i32 = -3;
                    const LEFT: i32 = -4;

                    struct Uniforms {
                        shapeMembers: f32,
                        shapeSize: f32,
                        updateInterval: f32,
                        maxShapes: f32,
                    };

                    struct Shape {
                        pos : vec2f,
                        v : vec2f,
                        w : f32,
                        angle : f32,
                        color : vec3f,
                    };

                    //util functions

                    fn isInf(n: f32) -> bool {
                        if(n > 10000000 || n < -10000000) {
                            return true;
                        }
                        return false;
                    }

                    fn readShape(arr: ptr<storage, array<f32>>, shapeIndex: u32) -> Shape {

                        let realIndex = u32(uniforms.shapeMembers)*shapeIndex;

                        var shapeIn: Shape;
                        shapeIn.pos = vec2f((*arr)[realIndex + 0], (*arr)[realIndex + 1]);
                        shapeIn.v = vec2f((*arr)[realIndex + 2], (*arr)[realIndex + 3]);
                        shapeIn.w = (*arr)[realIndex + 4];
                        shapeIn.angle = (*arr)[realIndex + 5];
                        shapeIn.color.r = (*arr)[realIndex + 6];
                        shapeIn.color.g = (*arr)[realIndex + 7];
                        shapeIn.color.b = (*arr)[realIndex + 8];
                        return shapeIn;
                    }
                    
                    fn writeShape(arr: ptr<storage, array<f32>, read_write>, shapeIndex: u32, shape: Shape) {
                    
                        let realIndex = u32(uniforms.shapeMembers)*shapeIndex;

                        (*arr)[realIndex + 0] = shape.pos.x;
                        (*arr)[realIndex + 1] = shape.pos.y;
                        (*arr)[realIndex + 2] = shape.v.x;
                        (*arr)[realIndex + 3] = shape.v.y;
                        (*arr)[realIndex + 4] = shape.w;
                        (*arr)[realIndex + 5] = shape.angle;
                        (*arr)[realIndex + 6] = shape.color.r;
                        (*arr)[realIndex + 7] = shape.color.g;
                        (*arr)[realIndex + 8] = shape.color.b;
                    }
                    
                    fn rotate(pos: vec2f, angle: f32) -> vec2f {
                        let rotMat = mat2x2f( vec2f(cos(angle), sin(angle)),
                                            vec2f(-sin(angle), cos(angle)));
                        let result = rotMat * pos;
                        return result;
                    }
                    
                    fn projVec(u: vec2f, v: vec2f) -> vec2f {
                        //project u on to v
                        return dot(u, v)/pow(length(v), 2)*v;
                    }

                    fn projVecScal(u: vec2f, v: vec2f) -> f32 {
                        //length of u projected on to v
                        return dot(u, v)/length(v);
                    }

                    fn getPoints(shape: Shape) -> array<vec2f, 4> {
                        var points = array<vec2f, 4>(vec2f(-1, -1), vec2f(-1, 1), vec2f(1, 1), vec2f(1, -1));    
                        
                        for(var i: u32 = 0; i < 4u; i = i + 1u) {
                            let p = points[i];
                            let scaledPos = p*uniforms.shapeSize;
                            let newPos = rotate(scaledPos, shape.angle) + shape.pos;
                            points[i] = newPos;
                        }
                        
                        return points;
                    }

                    fn testCollision(shape1: Shape, shape2: Shape) -> bool {
                        //get shape points
                        let points1: array<vec2f, 4> = getPoints(shape1);
                        let points2: array<vec2f, 4> = getPoints(shape2);

                        for(var s: u32 = 0; s < 2u; s = s + 1u) {
                            for(var i: u32 = 0; i < 4u; i = i + 1u) {
                                var v: vec2f;
                                if(s == 0) {
                                    v = points1[i] - points1[(i + 1) % 4];
                                } else {
                                    v = points2[i] - points2[(i + 1) % 4];
                                }

                                var p1Min: f32 = 100000;
                                var p1Max: f32 = -100000;
                                var p2Min: f32 = 100000;
                                var p2Max: f32 = -100000;

                                for(var j: u32 = 0; j < 4u; j = j + 1u) {
                                    let u = points1[j];
                                    let val = projVecScal(u, v);
                                    if(val < p1Min) {
                                        p1Min = val;
                                    }
                                    if(val > p1Max) {
                                        p1Max = val;
                                    }
                                }
                                for(var j: u32 = 0; j < 4u; j = j + 1u) {
                                    let u = points2[j];
                                    let val = projVecScal(u, v);
                                    if(val < p2Min) {
                                        p2Min = val;
                                    }
                                    if(val > p2Max) {
                                        p2Max = val;
                                    }
                                }

                                if(p1Min > p2Max ||
                                    p2Min > p1Max) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    
                    fn cTime(shape1: Shape, shape2: Shape) -> f32 {
                        // let diff: vec2f = shape1.pos - shape2.pos;
                        // let distance: f32 = sqrt(dot(diff, diff));
                        // return 1000;


                        //use taxi cab distance to predict x and y beign in bounds
                        let m: f32 = uniforms.shapeSize*2;
                        var xUpper: f32 = (m + shape1.pos.x - shape2.pos.x)/(shape2.v.x - shape1.v.x);
                        var xLower: f32 = (-m + shape1.pos.x - shape2.pos.x)/(shape2.v.x - shape1.v.x);
                        var yUpper: f32 = (m + shape1.pos.y - shape2.pos.y)/(shape2.v.y - shape1.v.y);
                        var yLower: f32 = (-m + shape1.pos.y - shape2.pos.y)/(shape2.v.y - shape1.v.y);

                        if(xUpper < xLower) {
                            let temp = xUpper;
                            xUpper = xLower;
                            xLower = temp;
                        }

                        if(yUpper < yLower) {
                            let temp = yUpper;
                            yUpper = yLower;
                            yLower = temp;
                        }

                        if(xLower < yUpper && xLower > yLower && xLower > 0) {
                            return xLower;
                        } else if(yLower < xUpper && yLower > xLower && yLower > 0) {
                            return yLower;
                        }
                        return 1000;
                    }

                    fn cTimeWalls(shape: Shape, wall: i32)  -> f32 {
                        let canvasSize: f32 = ${CANVAS_SIZE};
                        let m: f32 = uniforms.shapeSize;\
                        var time: f32 = -1;
                        if(wall == TOP) {
                            time = (-(shape.pos.y + m) + canvasSize)/shape.v.y;
                            if(shape.v.y < 0) {
                                time = -1;
                            }
                        } else if(wall == RIGHT) {
                            time = (-(shape.pos.x + m) + canvasSize)/shape.v.x;
                            if(shape.v.x < 0) {
                                time = -1;
                            }
                        } else if(wall == LEFT) {
                            time = (-(shape.pos.x - m) - canvasSize)/shape.v.x;
                            if(shape.v.x > 0) {
                                time = -1;
                            }
                        } else { //bottom
                            time = (-(shape.pos.y - m) - canvasSize)/shape.v.y;
                            if(shape.v.y > 0) {
                                time = -1;
                            }
                        }
                        if(time < 0 || isInf(time)) {
                            return 1000;
                        }
                        return time;
                    }

                    fn collideBottom(shape: ptr<function, Shape>) {
                        let difference = 1.0 - ((*shape).pos.y - uniforms.shapeSize);
                        if((*shape).pos.y - uniforms.shapeSize <= -1.0) {
                            shape.v.y = -shape.v.y;
                        }
                    }

                    fn xyToCIndex(x: i32, y: i32) -> u32 {
                        if(x < 0) {
                            let base: i32 = ${SHAPE_COLLISIONS};
                            return u32(base + y*4 - x - 1);
                        }
                        return u32(y*(y-1)/2 + x);
                    }
 
                    fn cIndexToXY(index: u32) -> vec2i {
                        let i: i32 = i32(index);
                        let base: i32 = ${SHAPE_COLLISIONS};
                        if(i > base - 1) {
                            let y: i32 = i32(floor(f32(i - base)/4));
                            let x: i32 = -((i - base) - y*4 + 1);
                            return vec2i(x,y);
                        }
                        let y: i32 = i32(floor((sqrt(f32(1+8*i))+1)/2));
                        let x: i32 = i - (y*(y-1))/2;
                        return vec2i(x,y);
                    }

                    fn updateShape(shape: ptr<function, Shape>, time: f32) {
                        (*shape).pos.x += shape.v.x * time;
                        (*shape).pos.y += shape.v.y * time;
                        (*shape).angle += shape.w * time;
                        // (*shape).color = vec3f(1.0, 1.0, 1.0);
                    }

                    fn collideShapes(shapeA: ptr<function, Shape>, shapeB: ptr<function, Shape>) {
                        (*shapeA).color.g *= 0.9;
                        (*shapeA).color.b *= 0.9;
                        (*shapeB).color.g *= 0.9;
                        (*shapeB).color.b *= 0.9;


                        let xDiff: f32 = (*shapeA).pos.x - (*shapeB).pos.x;
                        let yDiff: f32 = (*shapeA).pos.y - (*shapeB).pos.y;

                        if(abs(xDiff) > abs(yDiff)) {
                            let temp: f32 = (*shapeA).v.x;
                            (*shapeA).v.x = (*shapeB).v.x;
                            (*shapeB).v.x = temp;
                        } else {
                            let temp: f32 = (*shapeA).v.y;
                            (*shapeA).v.y = (*shapeB).v.y;
                            (*shapeB).v.y = temp;
                        }
                    }

                    fn collideWalls(shape: ptr<function, Shape>, wall: i32) {
                        if(wall == TOP || wall == BOTTOM) {
                            (*shape).v.y *= -1;
                        } else {
                            (*shape).v.x *= -1; 
                        }
                    }

                    var<workgroup> tileA: array<Shape, T>;
                    var<workgroup> tileB: array<Shape, T>;

                    @compute
                    @workgroup_size(T, T)
                    fn computeCTimes(@builtin(workgroup_id) wg: vec3u,
                                   @builtin(local_invocation_id) lid: vec3<u32>) {

                        var noOp = false;
                        if(remainingTime <= 0) {
                            noOp = true;
                        }

                        let bi = wg.x * T;
                        let bj = wg.y * T;
                        let gx = bi + lid.x;
                        let gy = bj + lid.y;

                        if(wg.x > wg.y || 
                            (wg.x == wg.y && lid.x >= lid.y) ||
                            noOp) {
                            //nothing
                        } else {
                            //copy global data to workgroup tiles
                            tileA[lid.x] = readShape(&shapeStateA, gx);
                            tileB[lid.y] = readShape(&shapeStateA, gy);

                            let time: f32 = cTime(tileA[lid.x], tileB[lid.y]);
                            let cTimeIndex = xyToCIndex(i32(gx), i32(gy));
                            collisionTimes[cTimeIndex] = time;
                        }
                        
                        workgroupBarrier();
                        
                        if(gx == 0 && !noOp) {
                            if(gy == 0) {
                                tileB[lid.y] = readShape(&shapeStateA, gy);
                            }
                            for(var s: i32 = -1; s > -5; s -= 1) {
                                let time: f32 = cTimeWalls(tileB[lid.y], s);
                                let index = xyToCIndex(s, i32(gy));
                                collisionTimes[index] = time;
                            }
                        }
                        
                        workgroupBarrier();
                        
                        //only one thread finds smallest collision time
                        if(gx == 0 && gy == 0 && !noOp) {
                            var shortestIndex: u32 = 0;
                            var shortestTime = collisionTimes[0];
                            for(var i: u32 = 1; i < ${COLLISIONS}; i = i + 1u) {
                                let time: f32 = collisionTimes[i];
                                if(time < shortestTime) {
                                    shortestIndex = i;
                                    shortestTime = time;
                                }
                            }
                            nextTimeIndex = shortestIndex;
                        }
                        
                    }

                    @compute
                    @workgroup_size(T)
                    fn computeStep(@builtin(workgroup_id) wg: vec3u,
                                   @builtin(local_invocation_id) lid: vec3<u32>) {
                        
                        let nextTimeIndex_ = nextTimeIndex;
                        let remainingTime_ = remainingTime;
                        let gx = wg.x * T + lid.x;

                        workgroupBarrier();

                        if(remainingTime_ == 0) {
                            var shape: Shape = readShape(&shapeStateA, gx);
                            writeShape(&shapeStateB, gx, shape);
                            if(gx == 0) {
                                remainingTime = -1;
                            }
                            return;
                        } else if(remainingTime_ == -1) {
                            return;
                        }
                        
                        var nextTime: f32 = collisionTimes[nextTimeIndex_];
                        var doCollision: bool = true;
                        if(nextTime > remainingTime_) {
                            nextTime = remainingTime_;
                            doCollision = false;
                        }

                        var shape: Shape = readShape(&shapeStateA, gx);
                        updateShape(&shape, nextTime);
                        
                        let cIndexXY: vec2i = cIndexToXY(nextTimeIndex_);
                        if(doCollision) {
                            if(cIndexXY.x == i32(gx)) {
                                var shapeCollided: Shape = readShape(&shapeStateA, u32(cIndexXY.y));
                                updateShape(&shapeCollided, nextTime);

                                collideShapes(&shape, &shapeCollided);
                                writeShape(&shapeStateB, u32(cIndexXY.y), shapeCollided);
                            } else if(u32(cIndexXY.y) == gx) {
                                if(cIndexXY.x < 0 ) {
                                    collideWalls(&shape, cIndexXY.x);
                                } else {
                                    return;
                                }
                            }
                        }
                        writeShape(&shapeStateB, gx, shape);

                        if(gx == 0) {
                            remainingTime = remainingTime_ - nextTime;
                        }

                    }
                    `
            });

            // create the bind group layout and pipeline layout
            const bindGroupLayout = device.createBindGroupLayout({
                label: "Shape Bind Group Layout",
                entries: [{
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,
                    buffer: {}
                }, {
                    binding: 1,
                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,
                    buffer: { type: "read-only-storage"}
                }, {
                    binding: 2,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: { type: "storage" }
                }, {
                    binding: 3,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: { type: "storage" }
                }, {
                    binding: 4,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: { type: "storage" }
                }, {
                    binding: 5,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: { type: "storage" }
                }]
                
            });

            const bindGroups = [
                device.createBindGroup({
                    label: "Cell renderer bind group A",
                    layout: bindGroupLayout,
                    entries: [
                    {
                        binding: 0,
                        resource: { buffer: uniformBuffer }
                    },
                    {
                        binding: 1,
                        resource: {buffer: shapeStateStorage[0]}
                    },
                    {
                        binding: 2,
                        resource: { buffer: shapeStateStorage[1] }
                    },
                    {
                        binding: 3,
                        resource: { buffer: colTimes }
                    },
                    {
                        binding: 4,
                        resource: { buffer: nextTimeIndexStorage }
                    },
                    {
                        binding: 5,
                        resource: { buffer: remainingTimeStorage }
                    }
                    ],
                }),
                device.createBindGroup({
                    label: "Cell renderer bind group B",
                    layout: bindGroupLayout,
                    entries: [
                    {
                        binding: 0,
                        resource: { buffer: uniformBuffer }
                    },
                    {
                        binding: 1,
                        resource: {buffer: shapeStateStorage[1]}
                    },
                    {
                        binding: 2,
                        resource: { buffer: shapeStateStorage[0] }
                    },
                    {
                        binding: 3,
                        resource: { buffer: colTimes }
                    },
                    {
                        binding: 4,
                        resource: { buffer: nextTimeIndexStorage }
                    },
                    {
                        binding: 5,
                        resource: { buffer: remainingTimeStorage }
                    }
                    ],
                })
            ];

            const pipelineLayout = device.createPipelineLayout({
                label: "Cell Pipeline Layout",
                bindGroupLayouts: [ bindGroupLayout ],
            });

            const cellPipeline = device.createRenderPipeline({
                label: "Cell pipeline",
                layout: pipelineLayout,
                vertex: {
                    module: cellShaderModule,
                    entryPoint: "vertexMain",
                    buffers: [vertexBufferLayout]
                },
                fragment: {
                    module: cellShaderModule,
                    entryPoint: "fragmentMain",
                    targets: [{
                        format: canvasFormat
                    }]
                }
            });

            const simulationPipelineCTimes = device.createComputePipeline({
                label: "Simulation pipeline for collision times",
                layout: pipelineLayout,
                compute: {
                    module: simulationShaderModule,
                    entryPoint: "computeCTimes",
                }
            });

            const simulationPipelinePStep = device.createComputePipeline({
                label: "Simulation pipeline for physics step",
                layout: pipelineLayout,
                compute: {
                    module: simulationShaderModule,
                    entryPoint: "computeStep",
                }
            });

            function updateUniforms(shapeMembers, shapeSize, updateInterval, maxShapes) {
                const uniformArray = new Float32Array([
                    shapeMembers,
                    shapeSize,
                    updateInterval,
                    maxShapes,
                ]);

                device.queue.writeBuffer(uniformBuffer, 0, uniformArray);
            }

            function updateGrid() {
                //begin compute pass

                device.queue.writeBuffer(remainingTimeStorage, 0, new Float32Array([UPDATE_INTERVAL]));

                const start = performance.now();

                const encoder = device.createCommandEncoder();

                const computePass = encoder.beginComputePass();

                const TILE_COUNT_DIM = MAX_SHAPES / TILE_SIZE;

                for(let i = 0; i < 8; i++) {
                    computePass.setBindGroup(0, bindGroups[i % 2]);

                    computePass.setPipeline(simulationPipelineCTimes);
                    computePass.dispatchWorkgroups(TILE_COUNT_DIM, TILE_COUNT_DIM);

                    computePass.setPipeline(simulationPipelinePStep);
                    computePass.dispatchWorkgroups(TILE_COUNT_DIM);
                }
                
                computePass.end();

                step++;

                //begin render pass
                
                const pass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        loadOp: "clear",
                        clearValue: [0, 0, 0, 1],
                        storeOp: "store",
                    }]
                });

                pass.setPipeline(cellPipeline);
                pass.setVertexBuffer(0, vertexBuffer);

                pass.setBindGroup(0, bindGroups[0]);

                pass.draw(vertices.length / 2, MAX_SHAPES);

                pass.end();
                const commandBuffer = encoder.finish();
                device.queue.submit([commandBuffer]);

                if(DO_FRAME_SYNCH) {
                    device.queue.onSubmittedWorkDone().then(() => {
                        frameElapsedTime = performance.now() - start;
                    });
                }
                setTimeout(() => {
                    updateGrid();
                }, UPDATE_INTERVAL - frameElapsedTime);
            }

            updateGrid();
            
        </script>
    </body>
</html>