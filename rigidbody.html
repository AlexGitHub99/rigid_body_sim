<!doctype HTML>

<html>
    <head>
        <meta charset="utf-8">
        <title>WebGPU rigidbodies</title>
    </head>
    <body>
        <canvas width="512" height="512"></canvas>
        <script type="module">
            const MAX_SHAPES = 5;
            const SHAPE_MEMBERS = 5;
            const SHAPE_SIZE = 0.05;
            
            const UPDATE_INTERVAL = 1000/60;
            let step = 0;

            const WORKGROUP_SIZE = 8;

            const canvas = document.querySelector("canvas");
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            const adapter = await navigator.gpu.requestAdapter();
            if(!adapter) {
                throw new Error("No appropritae GPUAdapter found.");
            }
            const device = await adapter.requestDevice();
            const context = canvas.getContext("webgpu");
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device: device,
                format: canvasFormat,
            });
            
            const uniformBuffer = device.createBuffer({
                label: "Uniforms",
                size: 32,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            updateUniforms(SHAPE_MEMBERS, SHAPE_SIZE, UPDATE_INTERVAL);

            //format is flattened array of [[posx, posy], [velx, vely], rot]
            const shapeStateArray = new Float32Array(MAX_SHAPES * SHAPE_MEMBERS);
            const shapeStateStorage = 
            [
                device.createBuffer({
                    label: "Shape State A",
                    size: shapeStateArray.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }),
                device.createBuffer({
                    label: "Shape State B",
                    size: shapeStateArray.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                })
            ];

            for (let i = 0; i < MAX_SHAPES; ++i) {
                shapeStateArray[i*SHAPE_MEMBERS + 0] = -0.8 + i*(SHAPE_SIZE*2.3); //pox
                shapeStateArray[i*SHAPE_MEMBERS + 1] = 0; //posy
                shapeStateArray[i*SHAPE_MEMBERS + 2] = 0; //velx
                shapeStateArray[i*SHAPE_MEMBERS + 3] = 0; //vely
                shapeStateArray[i*SHAPE_MEMBERS + 4] = 1; //rot
            }
            device.queue.writeBuffer(shapeStateStorage[0], 0, shapeStateArray);


            const vertices = new Float32Array([
            //   X,    Y,
                -1.0, -1.0,
                1.0, -1.0,
                -1.0,  1.0,

                1.0, -1.0,
                1.0,  1.0,
                -1.0,  1.0,
            ]);

            const vertexBuffer = device.createBuffer({
                labe: "Shape vertices",
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            })

            device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/0, vertices);

            const vertexBufferLayout = {
                arrayStride: 8,
                attributes: [{
                    format: "float32x2",
                    offset: 0,
                    shaderLocation: 0,
                }],
            };

            const cellShaderModule = device.createShaderModule({
                label: "Shape shader",
                code: `
                    // shader code
                    struct VertexInput {
                        @location(0) pos: vec2f,
                        @builtin(instance_index) instance: u32,
                    };

                    struct VertexOutput {
                        @builtin(position) pos: vec4f,
                    };

                    struct Uniforms {
                        shapeMembers: f32,
                        shapeSize: f32,
                        updateInterval: f32,
                    };

                    fn rotate(pos: vec2f, theta: f32) -> vec2f {
                        let rotMat = mat2x2f( vec2f(cos(theta), sin(theta)),
                                            vec2f(-sin(theta), cos(theta)));
                        let result = rotMat * pos;
                        return result;
                    }

                    @group(0) @binding(0) var<uniform> uniforms: Uniforms;
                    @group(0) @binding(1) var<storage> shapeState: array<f32>;

                    @vertex
                    fn vertexMain(input: VertexInput) -> VertexOutput {
                        let i = u32(input.instance);
                        let shapeMembers = u32(uniforms.shapeMembers);
                        let shapeIndex = i*shapeMembers;

                        let shapePos = vec2f(shapeState[shapeIndex + 0], shapeState[shapeIndex + 1]);
                        let shapeRot = shapeState[shapeIndex + 4];

                        let scaledPos = input.pos*uniforms.shapeSize;
                        let newPos = rotate(scaledPos, shapeRot) + shapePos;

                        var output: VertexOutput;
                        output.pos = vec4f(newPos, 0, 1);
                        return output;
                    }
                    
                    @fragment
                    fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
                        return vec4f(1, 1, 1, 1);
                    }
                `
            })

            const simulationShaderModule = device.createShaderModule({
                label: "Game of Life simulation shader",
                code: `
                    struct Uniforms {
                        shapeMembers: f32,
                        shapeSize: f32,
                        updateInterval: f32,
                    };

                    struct Shape {
                        pos : vec2f,
                        vel : vec2f,
                        rot : f32,
                    };

                    @group(0) @binding(0) var<uniform> uniforms: Uniforms;
                    @group(0) @binding(1) var<storage> shapeStateIn: array<f32>;
                    @group(0) @binding(2) var<storage, read_write> shapeStateOut: array<f32>;
                    
                    fn writeShapeOut(shapeIndex: u32, shape: Shape) {
                        shapeStateOut[shapeIndex + 0] = shape.pos.x;
                        shapeStateOut[shapeIndex + 1] = shape.pos.y;
                        shapeStateOut[shapeIndex + 2] = shape.vel.x;
                        shapeStateOut[shapeIndex + 3] = shape.vel.y;
                        shapeStateOut[shapeIndex + 4] = shape.rot;
                    }

                    fn collideBottom(shape: ptr<function, Shape>) {
                        let difference = 1.0 - ((*shape).pos.y - uniforms.shapeSize);
                        if((*shape).pos.y - uniforms.shapeSize <= -1.0) {
                            shape.vel.y = -shape.vel.y;
                        }
                    }

                    @compute
                    @workgroup_size(${WORKGROUP_SIZE})
                    fn computeMain(@builtin(global_invocation_id) cell: vec3u) {
                        let i = cell.x;
                        let shapeMembers = u32(uniforms.shapeMembers);
                        let shapeIndex = i*shapeMembers;
                        let updateInterval = uniforms.updateInterval;

                        var shapeIn: Shape;
                        shapeIn.pos = vec2f(shapeStateIn[shapeIndex + 0], shapeStateIn[shapeIndex + 1]);
                        shapeIn.vel = vec2f(shapeStateIn[shapeIndex + 2], shapeStateIn[shapeIndex + 3]);
                        shapeIn.rot = shapeStateIn[shapeIndex + 4];

                        var shapeOut: Shape;
                        shapeOut.pos = shapeIn.pos + shapeIn.vel*(updateInterval/1000);

                        //calculate acceleration
                        var acc = vec2(0, -4.9); //gravity
                        
                        shapeOut.vel = shapeIn.vel + acc*(updateInterval/1000);

                        collideBottom(&shapeOut);

                        shapeOut.rot = shapeIn.rot + 0.1;

                        
                        writeShapeOut(shapeIndex, shapeOut);
                    }
                    `
            });

            // create the bind group layout and pipeline layout
            const bindGroupLayout = device.createBindGroupLayout({
                label: "Shape Bind Group Layout",
                entries: [{
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,
                    buffer: {}
                }, {
                    binding: 1,
                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
                    buffer: { type: "read-only-storage"}
                }, {
                    binding: 2,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: { type: "storage" }
                }]
            });

            const bindGroups = [
                device.createBindGroup({
                    label: "Cell renderer bind group A",
                    layout: bindGroupLayout,
                    entries: [
                    {
                        binding: 0,
                        resource: { buffer: uniformBuffer }
                    },
                    {
                        binding: 1,
                        resource: {buffer: shapeStateStorage[0]}
                    },
                    {
                        binding: 2,
                        resource: { buffer: shapeStateStorage[1] }
                    }
                    ],
                }),
                device.createBindGroup({
                    label: "Cell renderer bind group B",
                    layout: bindGroupLayout,
                    entries: [
                    {
                        binding: 0,
                        resource: { buffer: uniformBuffer }
                    },
                    {
                        binding: 1,
                        resource: {buffer: shapeStateStorage[1]}
                    },
                    {
                        binding: 2,
                        resource: { buffer: shapeStateStorage[0] }
                    }
                    ],
                })
            ];

            const pipelineLayout = device.createPipelineLayout({
                label: "Cell Pipeline Layout",
                bindGroupLayouts: [ bindGroupLayout ],
            });

            const cellPipeline = device.createRenderPipeline({
                label: "Cell pipeline",
                layout: pipelineLayout,
                vertex: {
                    module: cellShaderModule,
                    entryPoint: "vertexMain",
                    buffers: [vertexBufferLayout]
                },
                fragment: {
                    module: cellShaderModule,
                    entryPoint: "fragmentMain",
                    targets: [{
                        format: canvasFormat
                    }]
                }
            });

            const simulationPipeline = device.createComputePipeline({
                label: "Simulation pipeline",
                layout: pipelineLayout,
                compute: {
                    module: simulationShaderModule,
                    entryPoint: "computeMain",
                }
            });

            function updateUniforms(shapeMembers, shapeSize, updateInterval) {
                const uniformArray = new Float32Array([
                    shapeMembers,
                    shapeSize,
                    updateInterval, 0
                ]);

                device.queue.writeBuffer(uniformBuffer, 0, uniformArray);
            }

            function updateGrid() {
                const encoder = device.createCommandEncoder();

                const computePass = encoder.beginComputePass();

                computePass.setPipeline(simulationPipeline);
                computePass.setBindGroup(0, bindGroups[step % 2]);

                const workgroupCount = Math.ceil(MAX_SHAPES / WORKGROUP_SIZE);
                computePass.dispatchWorkgroups(workgroupCount);

                computePass.end();

                step++;

                //begin render pass
                
                const pass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        loadOp: "clear",
                        clearValue: [0, 0, 0, 1],
                        storeOp: "store",
                    }]
                });

                pass.setPipeline(cellPipeline);
                pass.setVertexBuffer(0, vertexBuffer);

                pass.setBindGroup(0, bindGroups[step % 2]);

                pass.draw(vertices.length / 2, MAX_SHAPES);

                pass.end();
                const commandBuffer = encoder.finish();
                device.queue.submit([commandBuffer]);
            }

            setInterval(updateGrid, UPDATE_INTERVAL);
            
        </script>
    </body>
</html>